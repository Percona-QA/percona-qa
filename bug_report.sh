#!/bin/bash
# Created by Roel Van de Paar, MariaDB

MYEXTRA_OPT="$*"
SCRIPT_PWD=$(cd `dirname $0` && pwd)
RUN_PWD=${PWD}

if [ ! -r bin/mysqld ]; then
  echo "Assert: bin/mysqld not available, please run this from a basedir which had the SQL executed against it an crashed"
  exit 1
fi

if [ ! -r ./all_no_cl ]; then 
  echo "Assert: ./all_no_cl not available, please run this from a basedir which was prepared with ${SCRIPT_PWD}/startup.sh"
  exit 1
fi

if [ ! -r ../test_all ]; then
  echo "Assert: ../test_all not available - incorrect setup or structure"
  exit 1
fi

if [ ! -r ../kill_all ]; then
  echo "Assert: ../kill_all not available - incorrect setup or structure"
  exit 1
fi

if [ ! -r ../gendirs.sh ]; then
  echo "Assert: ../gendirs.sh not available - incorrect setup or structure"
  exit 1
fi

if [ ! -r ./in.sql ]; then
  echo "Assert: ./in.sql not available - incorrect setup or structure"
  exit 1
fi

echo 'Starting bug report generation for this SQL code (please check):'
echo '----------------------------------------------------------------'
cat in.sql
echo '----------------------------------------------------------------'
sleep 1

RANDOM=`date +%s%N | cut -b14-19`  # Random entropy init
RANDF=$(echo $RANDOM$RANDOM$RANDOM$RANDOM | sed 's|.\(..........\).*|\1|')  # Random 10 digits filenr

grep 'mysqld options required for replay:' ./in.sql | sed 's|.*mysqld options required for replay:[ ]||' > /tmp/options_bug_report.${RANDF}
echo ${MYEXTRA_OPT} >> /tmp/options_bug_report.${RANDF}
MYEXTRA_OPT_CLEANED=$(cat /tmp/options_bug_report.${RANDF} | sed 's|  | |g' | tr ' ' '\n' | sort -u | tr '\n' ' ')
if [ "$(echo "${MYEXTRA_OPT_CLEANED}" | sed 's|[ \t]||g')" != "" ]; then
  echo "Using the following options: ${MYEXTRA_OPT_CLEANED}"
fi

./all_no_cl ${MYEXTRA_OPT_CLEANED}
./test
./stop; sleep 0.2; ./kill 2>/dev/null; sleep 0.2

CORE_COUNT=$(ls data/*core* 2>/dev/null | wc -l)
if [ ${CORE_COUNT} -eq 0 ]; then
  echo "INFO: no cores found at data/*core*"
elif [ ${CORE_COUNT} -gt 1 ]; then
  echo "Assert: too many (${CORE_COUNT}) cores found at data/*core*, this should not happen (as ./all_no_cl was used which should have created a clean data directory)"
  exit 1
else
  gdb -q bin/mysqld $(ls data/*core*) >/tmp/${RANDF}.gdba 2>&1 << EOF
   set pagination off
   bt
   quit
EOF
fi

rm -f ../in.sql
if [ -r ../in.sql ]; then echo "Assert: ../in.sql still available after it was removed!"; exit 1; fi
cp in.sql ..
if [ ! -r ../in.sql ]; then echo "Assert: ../in.sql not available after copy attempt!"; exit 1; fi
cd ..
echo "Testing all..."
./test_all ${MYEXTRA_OPT_CLEANED}
echo "Ensuring are servers are gone..."
./kill_all  # NOTE: Can not be executed as ../kill_all as it requires ./gendirs.sh
CORE_COUNT_ALL=$(./gendirs.sh | xargs -I{} echo "ls {}/data/*core* 2>/dev/null" | xargs -I{} bash -c "{}" | wc -l)
cd -

SOURCE_CODE_REV="$(grep -om1 --binary-files=text "Source control revision id for MariaDB source code[^ ]\+" bin/mysqld 2>/dev/null | tr -d '\0' | sed 's|.*source code||;s|Version||')"
SERVER_VERSION="$(bin/mysqld --version | grep -om1 '[0-9\.]\+-MariaDB' | sed 's|-MariaDB||')"

echo '-------------------- BUG REPORT --------------------'
echo '{noformat}'
cat ./in.sql
echo -e '{noformat}\n'
echo -e 'Leads to:\n'
# Assumes (which is valid for the pquery framework) that 1st assertion is also the last in the log
ERROR_LOG=$(ls log/master.err 2>/dev/null | head -n1)
if [ ! -z "${ERROR_LOG}" ]; then
  ASSERT="$(grep --binary-files=text -m1 'Assertion.*failed.$' ${ERROR_LOG} | head -n1)"
  if [ ! -z "${ASSERT}" ]; then
    echo -e "{noformat:title=${SERVER_VERSION} ${SOURCE_CODE_REV}}\n${ASSERT}\n{noformat}\n"
  fi
fi

echo "{noformat:title=${SERVER_VERSION} ${SOURCE_CODE_REV}}"
NOCORE=0
if [ -r /tmp/${RANDF}.gdba ]; then
  grep -A999 'Core was generated by' /tmp/${RANDF}.gdba | grep -v '^(gdb)[ \t]*$' | grep -v '^[0-9]\+.*No such file or directory.$' | sed 's|(gdb) (gdb) |(gdb) bt\n|'
else
  NOCORE=1
  echo "THIS TESTCASE DID NOT CRASH ${SERVER_VERSION} (the version of the basedir in which you started this script), SO NO BACKTRACE IS SHOWN HERE. YOU CAN RE-EXECUTE THIS SCRIPT FROM ONE OF THE 'Bug confirmed present in' DIRECTORIES BELOW TO OBTAIN ONE, OR EXECUTE ./all_no_cl; ./test; ./gdb FROM WITHIN THAT DIRECTORY TO GET A BACKTRACE MANUALLY!"
fi
echo -e '{noformat}\n'
if [ -r ../test.results ]; then
  cat ../test.results
fi
echo '-------------------- /BUG REPORT --------------------'
echo "TOTAL CORES SEEN ACCROSS ALL VERSIONS: ${CORE_COUNT_ALL}"
if [ ${CORE_COUNT_ALL} -gt 0 ]; then
  echo 'Remember to action:'
  echo '1) If no engine is specified, add ENGINE=InnoDB'
  echo '2) Double check noformat version strings for non-10.5 issues'
  if [ ${NOCORE} -ne 1 ]; then
    echo '3A) Add bug to known.strings, as follows:'
    cd ${RUN_PWD}
    TEXT="$(${SCRIPT_PWD}/new_text_string.sh)"
    echo "${TEXT}"
    echo '3B) Checking if this bug is already known:'
    set +H  # Disables history substitution and avoids  -bash: !: event not found  like errors
    FINDBUG=$(grep -Fi --binary-files=text "${TEXT}" ${SCRIPT_PWD}/known_bugs.strings)
    if [ ! -z "${FINDBUG}" ]; then
      echo "FOUND: This is an already known bug!"
      echo "${FINDBUG}" 
    else
      echo "NOT FOUND: Bug not found yet in known_bugs.strings!"
      echo "*** THIS IS POSSIBLY A NEW BUG; BUT CHECK #4 BELOW FIRST! ***"
    fi
  else
    echo "3) Add bug to known.strings, using ${SCRIPT_PWD}/new_text_string.sh in the basedir of a crashed instance"
  fi
  echo '4) Check for duplicates before logging bug:'
  if [ ${NOCORE} -ne 1 ]; then
    cd ${RUN_PWD}
    FIRSTFRAME=$(${SCRIPT_PWD}/new_text_string.sh FRAMESONLY | sed 's/|.*//')
    echo "https://jira.mariadb.org/browse/MDEV-21938?jql=text%20~%20%22%5C%22${FIRSTFRAME}%5C%22%22"
    echo "https://www.google.com/search?q=site%3Amariadb.org+%22${FIRSTFRAME}%22"
  else
    echo "https://jira.mariadb.org/browse/MDEV-21938?jql=text%20~%20%22%5C%22\${FIRSTFRAME}%5C%22%22"
    echo "https://www.google.com/search?q=site%3Amariadb.org+%22\${FIRSTFRAME}%22"
    echo "Please swap \${FIRSTFRAME} in the above to the first frame name. Regrettably this script could not obtain it for you (ref 'THIS TESTCASE DID NOT...' note above), but you can choose to re-run it from one of the 'Bug confirmed present in' directories, and it will produce ready-made URL's for you."i
  fi
fi

